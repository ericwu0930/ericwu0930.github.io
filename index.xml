<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Eric&#39;s Blog</title>
    <link>https://ericwu0930.github.io/</link>
    <description>Recent content on Eric&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 11 Mar 2020 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://ericwu0930.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Java内存模型与锁优化</title>
      <link>https://ericwu0930.github.io/post/lock/</link>
      <pubDate>Wed, 11 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ericwu0930.github.io/post/lock/</guid>
      <description>1. Java内存模型 1.1 硬件的效率与一致性 基于高速缓存的存储交互很好的解决了处理器与内存的速度矛盾，但也为计算机系统带来更高的复杂度，因为它引入</description>
    </item>
    
    <item>
      <title>Java的四种引用以及ThreadLocal源码分析</title>
      <link>https://ericwu0930.github.io/post/reference/</link>
      <pubDate>Wed, 11 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ericwu0930.github.io/post/reference/</guid>
      <description>强引用： 只有所有的GC Roots对象都不通过强引用引用对象时，该对象才能被回收 软引用 当内存不足时，GC会把软引用指向的对象回收。软引用被经常</description>
    </item>
    
    <item>
      <title>ConcurrentHashMap源码分析</title>
      <link>https://ericwu0930.github.io/post/concurrenthashmap/</link>
      <pubDate>Mon, 09 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ericwu0930.github.io/post/concurrenthashmap/</guid>
      <description>本文总结自以下两篇博文，https://blog.csdn.net/weixin_44460333/article/details/8677</description>
    </item>
    
    <item>
      <title>内部类</title>
      <link>https://ericwu0930.github.io/post/innerclass/</link>
      <pubDate>Sat, 07 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ericwu0930.github.io/post/innerclass/</guid>
      <description>之前看过很多遍内部类，但总对其概念比较模糊，这次对其进行一个总结。 1. 内部类的特权 内部类指的是在一个类的内部所定义的类，类名不需要和源文件名相</description>
    </item>
    
    <item>
      <title>异常处理背后的JVM原理</title>
      <link>https://ericwu0930.github.io/post/exception/</link>
      <pubDate>Fri, 06 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ericwu0930.github.io/post/exception/</guid>
      <description>异常处理背后的JVM原理 1. 异常分类 Java体系中异常的组织分类如下图所示，所有异常类型的根类为 Throwable，具体包括两大类：Error</description>
    </item>
    
    <item>
      <title>红黑二叉树</title>
      <link>https://ericwu0930.github.io/post/redblackbst/</link>
      <pubDate>Tue, 03 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ericwu0930.github.io/post/redblackbst/</guid>
      <description>在一棵含有N个结点的树种，我们希望树高为~lgN，这样我们就能保证所有查找都能在~lgN次比较内结束，就和二分查找一样。但是在动态插入种保证</description>
    </item>
    
    <item>
      <title>HTTP协议</title>
      <link>https://ericwu0930.github.io/post/http/</link>
      <pubDate>Sun, 16 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ericwu0930.github.io/post/http/</guid>
      <description>1. Http的初步认识 1.1 Http的诞生 CERN的蒂姆·伯纳斯-李博士提出一种让全球研究者共享知识的设想：借助多文档之间互相关联形成的超文本，连</description>
    </item>
    
    <item>
      <title>TCP:控制传输协议</title>
      <link>https://ericwu0930.github.io/post/tcp/</link>
      <pubDate>Fri, 14 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ericwu0930.github.io/post/tcp/</guid>
      <description>1. TCP概述 不同于UDP，TCP提供一种面向连接的、可靠的字节流服务，没有由TCP自动插入的记录标志或消息边界，TCP根本不会解读字节流里的</description>
    </item>
    
    <item>
      <title>加密与安全机制</title>
      <link>https://ericwu0930.github.io/post/security/</link>
      <pubDate>Fri, 14 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ericwu0930.github.io/post/security/</guid>
      <description>加密是为了满足以下需求：在不安全的信道上保护所传输信息的机密性、完整性以及可认证性。有两种重要的加密算法——对称密钥与非对称密钥。 对称密钥 在</description>
    </item>
    
    <item>
      <title>Java内存区域</title>
      <link>https://ericwu0930.github.io/post/mem/</link>
      <pubDate>Sat, 18 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ericwu0930.github.io/post/mem/</guid>
      <description>Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的“高墙”，墙外面的人想进去，墙里面的人却想出来 1. 运行时数据区域 程序计数器：当前</description>
    </item>
    
    <item>
      <title>Java类中数据域初始化顺序</title>
      <link>https://ericwu0930.github.io/post/classinit/</link>
      <pubDate>Wed, 25 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://ericwu0930.github.io/post/classinit/</guid>
      <description>今天在做马士兵的坦克项目时，有个问题让我困惑了很久，翻阅了《深入理解Java虚拟机》以及《Java核心技术》之后，稍微找到了一些眉目，在这里</description>
    </item>
    
    <item>
      <title>多态在JVM中的体现</title>
      <link>https://ericwu0930.github.io/post/polymorphism/</link>
      <pubDate>Thu, 19 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://ericwu0930.github.io/post/polymorphism/</guid>
      <description>在《Java核心技术卷一》一书中，对方法调用有着比较明确的阐述。书中写道，假设要调用x.f(args)，隐式参数x声明为类C的一个对象，调用</description>
    </item>
    
    <item>
      <title>设计模式学习笔记</title>
      <link>https://ericwu0930.github.io/post/design/</link>
      <pubDate>Wed, 18 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://ericwu0930.github.io/post/design/</guid>
      <description>设计模式归根到底都是多态的变种 一、Singleton单例模式 只需要一个实例存在，比如PropertyMgr，即阻止别人随意new该对象 Key: 把构</description>
    </item>
    
    <item>
      <title>JVM方法调用过程</title>
      <link>https://ericwu0930.github.io/post/method/</link>
      <pubDate>Sun, 15 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://ericwu0930.github.io/post/method/</guid>
      <description>以Demo类中的main方法为例，讲解字节码在虚拟机运行的过程 public class Demo{ public static void main(String[] args) { int a=10; int b=Short.MAX_VALUE+1; int c=a+b; System.out.println(c); } } 通过javap反编译后的代码 eric@wuhaodeMacBook-Pro  ~/Desktop/jvM  javap -v Demo</description>
    </item>
    
    <item>
      <title>类加载器与双亲委派模型</title>
      <link>https://ericwu0930.github.io/post/classloader/</link>
      <pubDate>Tue, 10 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://ericwu0930.github.io/post/classloader/</guid>
      <description>在类加载过程的加载阶段，“通过一个类的全限定名来获取描述此类的二进制字节流”是通过“类加载器”来实现的。类加载器虽然只用于实现类的加载动作，</description>
    </item>
    
    <item>
      <title>JVM类加载机制</title>
      <link>https://ericwu0930.github.io/post/classload/</link>
      <pubDate>Tue, 03 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://ericwu0930.github.io/post/classload/</guid>
      <description>虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机</description>
    </item>
    
    <item>
      <title>JVM内存分配策略与GC时机</title>
      <link>https://ericwu0930.github.io/post/gc_3/</link>
      <pubDate>Sun, 01 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://ericwu0930.github.io/post/gc_3/</guid>
      <description>Java技术体系中所提倡的自动内存管理最终可以归结为自动化地解决两个问题：给对象分配内存以及回收分配给对象的内存。 在GC的第一篇总结笔记中提</description>
    </item>
    
    <item>
      <title>JVM垃圾收集器</title>
      <link>https://ericwu0930.github.io/post/gc_2/</link>
      <pubDate>Sat, 30 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://ericwu0930.github.io/post/gc_2/</guid>
      <description>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。 一、串行 单线程 堆内存较小，适合个人电脑 -XX: +UseSerialGC=Serial+SerialOld 新生代使用复制算法，老年代</description>
    </item>
    
    <item>
      <title>JVM垃圾收集策略</title>
      <link>https://ericwu0930.github.io/post/gc_1/</link>
      <pubDate>Fri, 29 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://ericwu0930.github.io/post/gc_1/</guid>
      <description>Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的“高墙”，墙外面的人想进去，墙里面的人却想出来 GC要解决的问题无非是以下三个：</description>
    </item>
    
    <item>
      <title>内存管理</title>
      <link>https://ericwu0930.github.io/post/memorymanage/</link>
      <pubDate>Mon, 30 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://ericwu0930.github.io/post/memorymanage/</guid>
      <description>如果不对内存抽象，会面临两个问题。第一，用户程序可以很容易的破坏才做系统；第二，想要同时运行多个程序比较困难，需要对程序进行重定位。于是现代</description>
    </item>
    
    <item>
      <title>进程和线程</title>
      <link>https://ericwu0930.github.io/post/process/</link>
      <pubDate>Tue, 10 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://ericwu0930.github.io/post/process/</guid>
      <description>1. 进程 1.1 概念 进程的经典定义是一个执行中的程序的实例。与每个进程相关的是地址空间，地址空间中存放有可执行程序、程序的数据以及程序的堆栈。与每个</description>
    </item>
    
    <item>
      <title></title>
      <link>https://ericwu0930.github.io/search/placeholder/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ericwu0930.github.io/search/placeholder/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://ericwu0930.github.io/top/about/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ericwu0930.github.io/top/about/</guid>
      <description>个人介绍 博主名叫吴昊，山东淄博人，高中就读于淄博市实验中学，本科就读于四川大学吴玉章学院，后保研至上海交通大学机械工程与动力学院机器人研究所，天资愚笨，在科研领域无所建树，后在代码世界中找到慰藉与乐趣，学习Java转码中，平时看书喜欢把笔记写成MD文档，在朋友建议下开设个人网站，平时会把笔记以及学习心得上传到本站。
受高中Homie影响，喜欢摄影，风光偏多，我会不定期的在本站中分享自己的摄影作品。电子产品爱好者，伪果粉，华为支持者，逐渐退烧。闲暇时间会打王者荣耀，徘徊于王者两星，不会打野。有颗向高雅艺术靠拢的心，但无奈身体很诚实的选择听流行音乐，最近常听Post Malone。
平日寡言，但喜与志同道合者畅谈，崇拜性感的大脑，欢迎通过各种方式与博主进行交流。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://ericwu0930.github.io/top/books/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ericwu0930.github.io/top/books/</guid>
      <description>Machine learning学习笔记 Coursera 在线课程 Machine learning 笔记讲师: 吴恩达(Andrew Ng) 课程地址：https://www.</description>
    </item>
    
  </channel>
</rss>